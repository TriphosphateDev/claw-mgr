<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Claw Mgr</title>
  <!-- build: remote-dropdowns -->
  <!-- __SERVED_FROM__ -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root { --mc-bg: #0d1117; --mc-card: #161b22; --mc-border: #30363d; --mc-text: #e6edf3; --mc-muted: #c9d1d9; }
    body { background: var(--mc-bg); color: var(--mc-text); font-size: 0.875rem; min-height: 100vh; }
    .mc-card { background: var(--mc-card); border: 1px solid var(--mc-border); border-radius: 6px; padding: 0.5rem 0.75rem; margin-bottom: 0.35rem; }
    .mc-card h6 { margin: 0 0 0.25rem 0; font-size: 0.75rem; font-weight: 600; color: #c9d1d9; text-transform: uppercase; letter-spacing: 0.02em; }
    .mc-list-item { padding: 0.25rem 0; border-bottom: 1px solid var(--mc-border); cursor: pointer; transition: background .15s; color: #e6edf3; }
    .mc-list-item:last-child { border-bottom: 0; }
    .mc-list-item:hover { background: rgba(255,255,255,.05); }
    .mc-list-item .small { color: #c9d1d9 !important; }
    .modal-content { background: var(--mc-card); border-color: var(--mc-border); color: var(--mc-text); }
    .modal-header, .modal-footer { border-color: var(--mc-border); }
    .modal-header .btn-close { filter: invert(1); }
    .form-select, .form-control { background: var(--mc-card); border-color: var(--mc-border); color: var(--mc-text); font-size: 0.875rem; }
    .form-select:focus, .form-control:focus { background: var(--mc-card); border-color: #58a6ff; color: var(--mc-text); box-shadow: 0 0 0 0.2rem rgba(88,166,255,.25); }
    .btn { font-size: 0.8125rem; padding: 0.25rem 0.5rem; }
    .btn-success { background: #238636; border-color: #238636; }
    .btn-danger { background: #da3633; border-color: #da3633; }
    .badge { font-size: 0.7rem; font-weight: 500; }
    pre { font-size: 0.75rem; background: #0d1117; padding: 0.5rem; border-radius: 4px; margin: 0; overflow-x: auto; }
    .status-dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; margin-right: 0.35rem; }
    .status-dot.ok { background: #3fb950; }
    .status-dot.err { background: #f85149; }
    .btn-outline-secondary { border-color: var(--mc-border); color: var(--mc-muted); }
    .btn-outline-secondary:hover { background: rgba(255,255,255,.08); border-color: var(--mc-border); color: var(--mc-text); }
    .accordion-item { background: var(--mc-card); border-color: var(--mc-border); }
    .accordion-button { background: #161b22; color: var(--mc-text); border-color: var(--mc-border); font-size: 0.875rem; padding: 0.4rem 0.75rem; }
    .accordion-button:not(.collapsed) { background: #21262d; color: var(--mc-text); box-shadow: none; }
    .accordion-button::after { filter: invert(1); }
    .accordion-button:focus { box-shadow: none; border-color: var(--mc-border); }
    .accordion-body { padding: 0.4rem 0.75rem; font-size: 0.8125rem; color: #c9d1d9; }
    .obj-row { padding: 0.2rem 0; border-bottom: 1px solid var(--mc-border); }
    .obj-row:last-child { border-bottom: 0; }
    .obj-key { color: #79c0ff; margin-right: 0.35rem; }
    #app .text-muted { color: #c9d1d9 !important; }
    #app .mc-card small { color: #c9d1d9 !important; }
    .mc-load-bar { height: 2px; background: linear-gradient(90deg, #58a6ff 0%, #58a6ff 30%, transparent 30%); background-size: 200% 100%; animation: mc-load-shift 0.8s ease-in-out infinite; }
    @keyframes mc-load-shift { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
  </style>
</head>
<body>
  <script>window.__OLLAMA_MODELS__ = []; window.__REMOTE_PROVIDERS__ = [];</script>
  <div id="app" class="container-fluid py-2 px-2 px-sm-3" style="max-width: 640px;">
    <h1 class="h5 mb-2 mt-1 fw-bold">Claw Mgr</h1>
    <div v-if="loading" class="mc-load-bar mb-2" style="border-radius: 1px;"></div>
    <div v-if="versionUpdateAvailable" class="small py-1 px-2 mb-2 rounded d-flex align-items-center justify-content-between" style="background: rgba(88, 166, 255, 0.15); border: 1px solid rgba(88, 166, 255, 0.4);">
      <span>New version <strong>{{ versionLatest }}</strong> available</span>
      <a href="https://github.com/Ascendism/claw-mgr" target="_blank" rel="noopener" class="btn btn-sm btn-outline-primary">Update</a>
    </div>

    <!-- Model + Gateway status + Start/Stop (always first) -->
    <div class="mc-card">
      <h6>Model</h6>
      <div class="d-flex align-items-center flex-wrap gap-2 mb-2">
        <template v-if="loading">
          <span class="spinner-border spinner-border-sm text-secondary" role="status"></span>
          <span class="small text-muted">Checking gateway…</span>
        </template>
        <template v-else>
          <span><span class="status-dot" :class="heartbeat.gateway?.ok ? 'ok' : 'err'"></span>Gateway {{ heartbeat.gateway?.ok ? 'up' : 'down' }}</span>
          <span v-if="heartbeat.state?.lastHeartbeatAt" class="small text-muted">Last {{ formatAgo(heartbeat.state.lastHeartbeatAt) }}</span>
        </template>
      </div>
      <div class="d-flex flex-wrap align-items-center gap-1 mb-1">
        <div class="btn-group btn-group-sm" role="group">
          <button type="button" class="btn" :class="mode === 'local' ? 'btn-primary' : 'btn-outline-secondary'" @click="setMode('local')">Local</button>
          <button type="button" class="btn" :class="mode === 'remote' ? 'btn-primary' : 'btn-outline-secondary'" @click="setMode('remote')">Remote</button>
        </div>
        <!-- Local: only Ollama dropdown (no remote provider UI) -->
        <template v-if="mode === 'local'">
          <select v-model="selectedModel" @change="saveLocalConfig" class="form-select form-select-sm" style="max-width: 200px;">
            <option value="">— select Ollama —</option>
            <option v-for="m in ollamaModels" :key="m.id" :value="m.id">{{ m.name }}</option>
          </select>
          <button v-if="ollamaModels.length === 0" type="button" class="btn btn-outline-secondary btn-sm" @click="fetchOllamaModels" :disabled="ollamaLoading">{{ ollamaLoading ? 'Loading…' : 'Refresh models' }}</button>
          <small v-if="ollamaModels.length === 0 && !ollamaLoading" class="text-muted">Is Ollama running?</small>
        </template>
        <!-- Remote: only provider + model (no Ollama dropdown) -->
        <template v-if="mode === 'remote'">
          <select v-model="remoteProvider" @change="onRemoteProviderChange" class="form-select form-select-sm" style="min-width: 130px; max-width: 160px;" title="Choose API provider">
            <option value="">— provider —</option>
            <option v-for="p in remoteProviders" :key="p.id" :value="p.id">{{ p.label }}</option>
            <option v-if="remoteProviders.length === 0" value="" disabled>Loading…</option>
          </select>
          <select v-if="remoteProvider && remoteProvider !== 'other'" v-model="remoteModel" @change="saveRemoteConfig" class="form-select form-select-sm" style="min-width: 160px; max-width: 220px;">
            <option value="">— model —</option>
            <option v-for="m in currentRemoteProviderModels" :key="modelId(m)" :value="modelId(m)">{{ modelLabel(m) }}</option>
          </select>
          <input v-if="remoteProvider === 'other'" v-model="remoteCustomModel" @input="saveRemoteConfig" type="text" class="form-control form-control-sm" style="min-width: 120px; max-width: 180px;" placeholder="provider/model" />
        </template>
        <button class="btn btn-success btn-sm" :disabled="!canStart || state.running.gateway" @click="start">Start</button>
        <button class="btn btn-danger btn-sm" :disabled="!state.running.gateway && !state.running.dashboard" @click="stop">Stop</button>
      </div>
      <small class="text-muted" v-if="loading">Loading…</small>
      <small class="text-muted" v-else-if="!state.running.gateway">Saved: {{ mode }} · {{ state.model || config[mode]?.model || '—' }}</small>
      <small class="text-muted" v-else-if="state.running.gateway">Running · {{ state.mode || mode }} · {{ state.model || '—' }}</small>
    </div>

    <!-- Remote API options (only when Remote mode) -->
    <div class="mc-card" v-if="mode === 'remote'">
      <h6>Remote API</h6>
      <div v-if="remoteProvider && remoteCredsCheck.envKey" class="mb-2 p-2 rounded" :class="remoteCredsCheck.set ? 'bg-success bg-opacity-10 border border-success border-opacity-25' : 'bg-warning bg-opacity-10 border border-warning border-opacity-25'">
        <template v-if="remoteCredsCheck.set">
          <small class="text-success">Using <code>{{ remoteCredsCheck.envKey }}</code> from environment.</small>
        </template>
        <template v-else>
          <small class="text-warning"><strong>No API key found.</strong> To use {{ remoteProvider === 'other' ? 'this provider' : remoteProvider }}:</small>
          <ol class="small mb-0 mt-1 ps-3 text-muted">
            <li>Add to <code>~/.openclaw/.env</code>: <code>{{ remoteCredsCheck.envKey }}=your-api-key</code></li>
            <li>Or enter the key below (used only when you click Start; not saved).</li>
          </ol>
        </template>
      </div>
      <div v-else-if="remoteProvider === 'other'" class="mb-2 p-2 rounded bg-warning bg-opacity-10 border border-warning border-opacity-25">
        <small class="text-muted">For custom providers: set your API key env var in <code>~/.openclaw/.env</code> (e.g. <code>CUSTOM_API_KEY=your-key</code>) or enter the key below when starting.</small>
      </div>
      <div class="row g-1 mb-1">
        <div class="col-12 col-sm-6">
          <label class="form-label small mb-0 text-muted">Provider</label>
          <select v-model="remoteProvider" @change="onRemoteProviderChange" class="form-select form-select-sm">
            <option value="">— select —</option>
            <option v-for="p in remoteProviders" :key="p.id" :value="p.id">{{ p.label }}</option>
          </select>
        </div>
        <div class="col-12 col-sm-6" v-if="remoteProvider && remoteProvider !== 'other'">
          <label class="form-label small mb-0 text-muted">Model</label>
          <select v-model="remoteModel" @change="saveRemoteConfig" class="form-select form-select-sm">
            <option value="">— select —</option>
            <option v-for="m in currentRemoteProviderModels" :key="modelId(m)" :value="modelId(m)">{{ modelLabel(m) }}</option>
          </select>
        </div>
        <div class="col-12 col-sm-6" v-if="remoteProvider === 'other'">
          <label class="form-label small mb-0 text-muted">Model (provider/id)</label>
          <input v-model="remoteCustomModel" @input="saveRemoteConfig" type="text" class="form-control form-control-sm" placeholder="e.g. custom/gpt-4o" />
        </div>
        <div class="col-12 col-sm-6" v-if="remoteProvider === 'other'">
          <label class="form-label small mb-0 text-muted">API key env var (optional)</label>
          <input v-model="remoteCustomEnvKey" @input="saveRemoteConfig" type="text" class="form-control form-control-sm" placeholder="e.g. CUSTOM_API_KEY" />
        </div>
      </div>
      <div class="row g-1 mb-1">
        <div class="col-12 col-sm-6">
          <label class="form-label small mb-0 text-muted">API key (optional)</label>
          <input v-model="remoteApiKey" type="password" class="form-control form-control-sm" :placeholder="remoteCredsCheck.set ? 'Using env' : 'Paste key or set in ~/.openclaw/.env'" autocomplete="off" />
        </div>
        <div class="col-12 col-sm-6">
          <label class="form-label small mb-0 text-muted">Base URL (optional)</label>
          <input v-model="remoteBaseUrl" @input="saveRemoteConfig" type="text" class="form-control form-control-sm" placeholder="https://api.example.com/v1" />
        </div>
      </div>
      <small class="text-muted" v-if="currentRemoteEnvKey">Env key: {{ currentRemoteEnvKey }}</small>
    </div>

    <!-- Dashboard -->
    <div class="mc-card">
      <h6>Dashboard</h6>
      <div class="d-flex align-items-center justify-content-between gap-2 mb-1">
          <small class="text-muted">OpenClaw status snapshot</small>
          <div class="d-flex align-items-center gap-1">
            <button class="btn btn-outline-secondary btn-sm" @click="showDashboardRaw = !showDashboardRaw">{{ showDashboardRaw ? 'Hide raw' : 'Show raw' }}</button>
            <button class="btn btn-outline-secondary btn-sm" @click="refreshDashboard">Refresh</button>
          </div>
        </div>
        <div class="small mb-1" v-if="dashboardSummaryParsed">
          <div class="obj-row"><span class="obj-key">Gateway:</span>{{ dashboardSummaryParsed.gateway || '-' }}</div>
          <div class="obj-row"><span class="obj-key">Agents:</span>{{ dashboardSummaryParsed.agents || '-' }}</div>
          <div class="obj-row"><span class="obj-key">Sessions:</span>{{ dashboardSummaryParsed.sessions || '-' }}</div>
          <div class="obj-row"><span class="obj-key">Heartbeat:</span>{{ dashboardSummaryParsed.heartbeat || '-' }}</div>
          <div class="obj-row" v-if="dashboardSummaryParsed.security"><span class="obj-key">Security:</span>{{ dashboardSummaryParsed.security.critical }} critical · {{ dashboardSummaryParsed.security.warn }} warn · {{ dashboardSummaryParsed.security.info }} info</div>
      </div>
      <pre v-if="showDashboardRaw" style="max-height: 180px;">{{ dashboardSummaryRaw || 'No snapshot yet.' }}</pre>
    </div>

    <!-- Cron jobs -->
    <div class="mc-card">
      <h6>Cron jobs</h6>
      <div v-if="cronJobs.length === 0" class="small text-muted py-1">None</div>
      <div v-else>
        <div v-for="j in cronJobs" :key="j.jobId || j.name" class="mc-list-item d-flex justify-content-between align-items-center">
          <span @click="openCron(j)" style="cursor:pointer;">{{ j.name }}</span>
          <div class="d-flex align-items-center gap-2">
            <span class="small text-muted">{{ formatCronWhen(j) }}</span>
            <div class="d-flex align-items-center gap-1">
              <button class="btn btn-outline-secondary btn-sm" @click="openCronRuns(j)">Runs</button>
              <button class="btn btn-outline-secondary btn-sm" @click="runCronJob(j)">Run</button>
              <span class="badge" :class="j.enabled ? 'bg-success' : 'bg-secondary'">{{ j.enabled ? 'on' : 'off' }}</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Subagents -->
    <div class="mc-card">
      <h6>Subagents</h6>
      <div class="row g-1 align-items-center mb-1">
        <div class="col-12">
          <label class="form-label small mb-0 text-muted">Label (optional)</label>
          <input v-model="spawnLabel" type="text" class="form-control form-control-sm" placeholder="e.g. clawmgr-run-1" />
        </div>
        <div class="col-12">
          <label class="form-label small mb-0 text-muted">Task</label>
          <textarea v-model="spawnTask" class="form-control form-control-sm" rows="4" placeholder="Paste the role header + task contract here..."></textarea>
        </div>
        <div class="col-12 d-flex gap-1">
          <button class="btn btn-success btn-sm" :disabled="!spawnTask.trim() || spawning" @click="spawnSession">Spawn</button>
          <button class="btn btn-outline-secondary btn-sm" :disabled="loadingSessions" @click="refreshSessions">Refresh</button>
          <small class="text-muted ms-auto" v-if="sessionsError">{{ sessionsError }}</small>
        </div>
      </div>

      <div v-if="sessions.length === 0" class="small text-muted py-1">No sessions</div>
      <div v-else>
        <div v-for="s in sessions" :key="s.key" class="mc-list-item d-flex justify-content-between align-items-center" @click="openSession(s)">
          <span class="small">{{ s.label || s.key }}</span>
          <div class="d-flex align-items-center gap-1">
            <span class="badge bg-secondary" v-if="s.kind">{{ s.kind }}</span>
            <button class="btn btn-outline-secondary btn-sm" @click.stop="openSession(s)">View</button>
            <button class="btn btn-danger btn-sm" @click.stop="deleteSession(s)">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Activity detail modal (inside #app so Vue compiles it) -->
    <div class="modal fade" id="activityModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header py-2">
            <h6 class="modal-title">{{ detailActivity.date }}</h6>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body py-2">
            <p class="mb-1">{{ detailActivity.description }}</p>
            <small class="text-muted">File: {{ detailActivity.file }}</small>
          </div>
        </div>
      </div>
    </div>

    <!-- Cron detail modal (inside #app so Vue compiles it) -->
    <div class="modal fade" id="cronModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header py-2">
            <h6 class="modal-title">{{ detailCron.name || 'Cron job' }}</h6>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body py-2">
            <div class="mb-2 p-2 rounded bg-opacity-10" style="background: var(--mc-border);">
              <div class="obj-row"><span class="obj-key">Last run:</span> {{ formatCronLastRunFull(detailCron.lastRunTs) }}</div>
              <div class="obj-row" v-if="detailCron.lastRunStatus"><span class="obj-key">Status:</span> {{ detailCron.lastRunStatus }}</div>
            </div>
            <div class="accordion" v-if="detailCron.schedule || detailCron.payload">
              <div class="accordion-item" v-if="detailCron.schedule">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#cronDetailSchedule">Schedule</button>
                </h2>
                <div id="cronDetailSchedule" class="accordion-collapse collapse">
                  <div class="accordion-body py-1">
                    <json-accordion :data="detailCron.schedule" id-prefix="cron-schedule"></json-accordion>
                  </div>
                </div>
              </div>
              <div class="accordion-item" v-if="detailCron.payload">
                <h2 class="accordion-header">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#cronDetailPayload">Payload</button>
                </h2>
                <div id="cronDetailPayload" class="accordion-collapse collapse">
                  <div class="accordion-body py-1">
                    <json-accordion :data="detailCron.payload" id-prefix="cron-payload"></json-accordion>
                  </div>
                </div>
              </div>
            </div>
            <p class="mb-1 mt-2" v-if="detailCron.sessionTarget"><strong>Target</strong> {{ detailCron.sessionTarget }}</p>
            <span class="badge" :class="detailCron.enabled !== false ? 'bg-success' : 'bg-secondary'">{{ detailCron.enabled !== false ? 'enabled' : 'disabled' }}</span>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="cronRunsModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header py-2">
            <h6 class="modal-title">Runs · {{ detailCron.name || detailCron.jobId }}</h6>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body py-2">
            <div v-if="cronRuns.length === 0" class="small text-muted">No runs found.</div>
            <div v-for="(r, idx) in cronRuns" :key="idx" class="mc-card mb-1">
              <div class="d-flex align-items-center justify-content-between">
                <strong>{{ r.status || r.action || 'run' }}</strong>
                <small class="text-muted">{{ r.ts ? new Date(r.ts).toLocaleString() : 'unknown time' }}</small>
              </div>
              <pre>{{ JSON.stringify(r, null, 2) }}</pre>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Session output modal -->
    <div class="modal fade" id="sessionModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header py-2">
            <h6 class="modal-title">Session {{ detailSession.key || '—' }}</h6>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body py-2">
            <div class="d-flex gap-1 mb-2">
              <button class="btn btn-outline-secondary btn-sm" @click="reloadSessionHistory" :disabled="loadingSessionHistory">Pull latest</button>
              <small class="text-muted" v-if="sessionHistoryError">{{ sessionHistoryError }}</small>
            </div>
            <pre v-if="detailSessionHistoryText">{{ detailSessionHistoryText }}</pre>
            <div v-else class="small text-muted">No history loaded.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/relativeTime.js"></script>
  <script src="/vendor/vue.global.prod.js"></script>
  <script>try { if (window.dayjs && window.dayjs_plugin_relativeTime) dayjs.extend(dayjs_plugin_relativeTime); } catch(e){}</script>
  <script>
    Vue.config.productionTip = false;
    Vue.filter('truncate', function (v, len) {
      if (!v) return '';
      return v.length <= len ? v : v.slice(0, len) + '…';
    });

    Vue.component('json-accordion', {
      name: 'JsonAccordion',
      props: { data: { type: Object, default: null }, idPrefix: { type: String, default: 'obj' } },
      template: '<div class="accordion" v-if="data">' +
        '<div class="accordion-item" v-for="(value, key) in data" :key="key">' +
          '<h2 class="accordion-header">' +
            '<button class="accordion-button collapsed" type="button" :data-bs-toggle="\'collapse\'" :data-bs-target="\'#\' + safeId(key)" aria-expanded="false">' +
              '{{ key }}' +
            '</button>' +
          '</h2>' +
          '<div :id="safeId(key)" class="accordion-collapse collapse">' +
            '<div class="accordion-body py-1">' +
              '<template v-if="isObject(value)">' +
                '<json-accordion :data="value" :id-prefix="idPrefix + \'-\' + safeId(key)"></json-accordion>' +
              '</template>' +
              '<template v-else-if="Array.isArray(value)">' +
                '<ul class="list-unstyled mb-0 small"><li v-for="(item, i) in value" :key="i" class="obj-row"><span class="obj-key">{{ i }}:</span> {{ item }}</li></ul>' +
              '</template>' +
              '<div v-else class="obj-row">{{ value }}</div>' +
            '</div>' +
          '</div>' +
        '</div>' +
      '</div>',
      methods: {
        safeId(key) {
          return this.idPrefix + '-' + String(key).replace(/[^a-z0-9-_]/gi, '-');
        },
        isObject(v) {
          return v !== null && typeof v === 'object' && !Array.isArray(v);
        }
      }
    });

    new Vue({
      el: '#app',
      data: {
        mode: 'local',
        selectedModel: '',
        ollamaModels: [],
        ollamaLoading: false,
        config: { mode: 'local', local: {}, remote: {} },
        state: { gatewayPid: null, dashboardPid: null, model: null, mode: null, running: { gateway: false, dashboard: false } },
        activity: [],
        cronJobs: [],
        heartbeat: { gateway: {}, state: {} },
        dashboardSummaryRaw: '',
        dashboardSummaryParsed: null,
        showDashboardRaw: false,
        cronRuns: [],
        detailActivity: {},
        detailCron: {},
        activityModal: null,
        cronModal: null,
        cronRunsModal: null,

        // Subagents
        sessions: [],
        loadingSessions: false,
        sessionsError: '',
        spawnLabel: '',
        spawnTask: '',
        spawning: false,
        sessionModal: null,
        detailSession: {},
        detailSessionHistory: null,
        loadingSessionHistory: false,
        sessionHistoryError: '',
        remoteProviders: (typeof window !== 'undefined' && window.__REMOTE_PROVIDERS__) ? window.__REMOTE_PROVIDERS__ : [],
        remoteProvider: '',
        remoteModel: '',
        remoteCustomModel: '',
        remoteApiKey: '',
        remoteBaseUrl: '',
        remoteCustomEnvKey: '',
        remoteCredsCheck: { envKey: null, set: false },
        loading: true,
        versionUpdateAvailable: false,
        versionLatest: '',
      },
      computed: {
        currentRemoteProviderModels() {
          const p = this.remoteProviders.find((x) => x.id === this.remoteProvider);
          return p && p.models ? p.models : [];
        },
        currentRemoteEnvKey() {
          if (this.remoteProvider === 'other') return this.remoteCustomEnvKey || this.config.remote?.apiKeyEnv || '';
          const p = this.remoteProviders.find((x) => x.id === this.remoteProvider);
          return p && p.envKey ? p.envKey : '';
        },
        displayRemoteModel() {
          return this.effectiveRemoteModel || '—';
        },
        effectiveRemoteModel() {
          if (this.remoteProvider === 'other') return this.remoteCustomModel || this.config.remote?.model || '';
          if (this.remoteProvider && this.remoteModel) return this.remoteProvider + '/' + this.remoteModel;
          return this.config.remote?.model || '';
        },
        detailSessionHistoryText() {
          if (!this.detailSessionHistory) return '';
          try {
            return JSON.stringify(this.detailSessionHistory, null, 2);
          } catch (e) {
            return String(this.detailSessionHistory);
          }
        },
      },
      mounted() {
        if (window.__OLLAMA_MODELS__ && window.__OLLAMA_MODELS__.length) {
          this.ollamaModels = window.__OLLAMA_MODELS__;
        } else if (this.mode === 'local') {
          this.fetchOllamaModels();
        }
        this.activityModal = new bootstrap.Modal(document.getElementById('activityModal'));
        this.cronModal = new bootstrap.Modal(document.getElementById('cronModal'));
        this.cronRunsModal = new bootstrap.Modal(document.getElementById('cronRunsModal'));
        this.sessionModal = new bootstrap.Modal(document.getElementById('sessionModal'));
        this.refresh();
        setInterval(this.refresh, 25000);
      },
      methods: {
        formatAgo(ts) {
          const s = Math.floor((Date.now() - ts) / 1000);
          if (s < 60) return 'just now';
          if (s < 3600) return Math.floor(s / 60) + 'm ago';
          if (s < 86400) return Math.floor(s / 3600) + 'h ago';
          return Math.floor(s / 86400) + 'd ago';
        },
        formatCronWhen(j) {
          if (!j) return '—';
          // schedule.at (e.g. schedule >> at) or top-level at when kind is 'at'
          const atVal = (j.schedule && (j.schedule.at != null && j.schedule.at !== '')) ? j.schedule.at : (j.kind === 'at' && (j.at != null && j.at !== '') ? j.at : null);
          if (atVal == null) return '—';
          const ts = typeof atVal === 'number' ? atVal : new Date(atVal).getTime();
          if (isNaN(ts)) return '—';
          if (typeof dayjs !== 'undefined') return dayjs(ts).format('ddd, MMM D · h:mm A');
          return new Date(ts).toLocaleString(undefined, { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' });
        },
        formatCronLastRun(ts) {
          if (ts == null || ts === '') return 'Never run';
          if (typeof dayjs !== 'undefined' && dayjs(ts).fromNow) return dayjs(ts).fromNow();
          return this.formatAgo(ts);
        },
        formatCronLastRunFull(ts) {
          if (ts == null || ts === '') return 'Never run';
          if (typeof dayjs !== 'undefined') return dayjs(ts).format('ddd, MMM D, YYYY · h:mm A');
          return new Date(ts).toLocaleString();
        },
        async refresh() {
          try {
            const [stateRes, activityRes, cronRes, heartbeatRes, dashboardRes, configRes, providersRes, sessionsRes] = await Promise.all([
              fetch('/api/state'),
              fetch('/api/activity'),
              fetch('/api/cron'),
              fetch('/api/heartbeat'),
              fetch('/api/dashboard/summary').catch(() => ({ ok: false })),
              fetch('/api/config').catch(() => ({ ok: false })),
              fetch('/api/remote-providers').catch(() => ({ ok: false })),
              fetch('/api/sessions').catch(() => ({ ok: false })),
            ]);

            // State first (so "running" can win over config for hydration)
            if (stateRes.ok) this.state = await stateRes.json();
            if (activityRes.ok) this.activity = await activityRes.json();
            if (cronRes.ok) this.cronJobs = (await cronRes.json()).jobs || [];
            if (heartbeatRes.ok) this.heartbeat = await heartbeatRes.json();
            if (dashboardRes.ok) {
              const dash = await dashboardRes.json();
              this.dashboardSummaryRaw = dash?.data?.raw || '';
              this.dashboardSummaryParsed = dash?.data?.parsed || null;
            }
            if (providersRes.ok) {
              const data = await providersRes.json();
              this.remoteProviders = data.providers || [];
            }
            if (versionRes.ok) {
              const v = await versionRes.json();
              this.versionUpdateAvailable = !!v.updateAvailable;
              this.versionLatest = v.latestVersion || '';
            }

            // Subagents sessions list (best-effort)
            if (sessionsRes && sessionsRes.ok) {
              const data = await sessionsRes.json();
              const result = data && data.result ? data.result : (data && data.result === null ? null : data.result);
              // Our server returns { ok:true, result: <rpc result> }
              if (data && data.ok && data.result && data.result.sessions) {
                this.sessions = data.result.sessions;
                this.sessionsError = '';
              } else if (data && data.ok && Array.isArray(data.result?.sessions)) {
                this.sessions = data.result.sessions;
                this.sessionsError = '';
              } else if (data && data.ok && data.result) {
                // In case gateway shape changes, try a few common shapes.
                this.sessions = data.result.sessions || data.result || [];
                this.sessionsError = '';
              }
            }

            // Config (saved preferences)
            if (configRes.ok) {
              const cfg = await configRes.json();
              this.config = cfg;

              // Hydrate from config defaults
              if (cfg.mode) this.mode = cfg.mode;
              if (cfg.local?.model) this.selectedModel = cfg.local.model;

              if (cfg.remote) {
                this.remoteProvider = cfg.remote.provider || '';
                this.remoteBaseUrl = cfg.remote.baseUrl || '';
                this.remoteCustomEnvKey = cfg.remote.apiKeyEnv || '';
                this.remoteModel = '';
                this.remoteCustomModel = '';

                if (cfg.remote.model) {
                  const slash = cfg.remote.model.indexOf('/');
                  if (slash > 0) {
                    const prov = cfg.remote.model.slice(0, slash);
                    const modelId = cfg.remote.model.slice(slash + 1);
                    if (prov === 'other' || !this.remoteProviders.find((p) => p.id === prov)) {
                      this.remoteProvider = 'other';
                      this.remoteCustomModel = cfg.remote.model;
                    } else {
                      this.remoteProvider = prov;
                      this.remoteModel = modelId;
                    }
                  } else {
                    this.remoteCustomModel = cfg.remote.model;
                  }
                }
              }
            }

            // If the gateway is running, prefer the currently running mode/model.
            if (this.state && this.state.running && this.state.running.gateway) {
              if (this.state.mode) this.mode = this.state.mode;
              if (this.state.model) {
                if (this.mode === 'local') {
                  this.selectedModel = this.state.model;
                } else if (this.mode === 'remote') {
                  const runningModel = String(this.state.model);
                  const slash = runningModel.indexOf('/');
                  if (slash > 0) {
                    const prov = runningModel.slice(0, slash);
                    const modelId = runningModel.slice(slash + 1);
                    if (prov === 'other' || !this.remoteProviders.find((p) => p.id === prov)) {
                      this.remoteProvider = 'other';
                      this.remoteCustomModel = runningModel;
                      this.remoteModel = '';
                    } else {
                      this.remoteProvider = prov;
                      this.remoteModel = modelId;
                      this.remoteCustomModel = '';
                    }
                  } else {
                    this.remoteProvider = 'other';
                    this.remoteCustomModel = runningModel;
                    this.remoteModel = '';
                  }
                }
              }
            }

            // Models list
            const modelsRes = await fetch('/api/ollama-models');
            if (modelsRes.ok) {
              const data = await modelsRes.json();
              this.ollamaModels = data.models || [];
              if (!this.selectedModel && this.ollamaModels.length) this.selectedModel = this.ollamaModels[0].id;
            } else if (this.ollamaModels.length === 0 && window.__OLLAMA_MODELS__) {
              this.ollamaModels = window.__OLLAMA_MODELS__;
              if (!this.selectedModel && this.ollamaModels.length) this.selectedModel = this.ollamaModels[0].id;
            }
            if (this.mode === 'remote' && this.remoteProvider) {
              this.checkRemoteCredentials();
            }
          } catch (e) {}
          finally {
            this.loading = false;
          }
        },
        async checkRemoteCredentials() {
          if (!this.remoteProvider) {
            this.remoteCredsCheck = { envKey: null, set: false };
            return;
          }
          try {
            const params = new URLSearchParams();
            if (this.remoteProvider !== 'other') params.set('provider', this.remoteProvider);
            if (this.remoteProvider === 'other' && this.currentRemoteEnvKey) params.set('apiKeyEnv', this.currentRemoteEnvKey);
            const res = await fetch('/api/check-remote-credentials?' + params.toString());
            if (res.ok) this.remoteCredsCheck = await res.json();
            else this.remoteCredsCheck = { envKey: null, set: false };
          } catch (e) {
            this.remoteCredsCheck = { envKey: null, set: false };
          }
        },
        canStart() {
          if (this.mode === 'local') return !!this.selectedModel;
          return !!this.effectiveRemoteModel;
        },
        modelId(m) {
          return typeof m === 'object' && m && m.id != null ? m.id : m;
        },
        modelLabel(m) {
          if (typeof m === 'object' && m && m.id != null) {
            return m.ctx ? m.id + ' · ' + m.ctx : m.id;
          }
          return String(m);
        },
        async setMode(nextMode) {
          this.mode = nextMode;
          if (nextMode === 'local' && this.ollamaModels.length === 0) {
            this.fetchOllamaModels();
          }
          try {
            await fetch('/api/config', {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ mode: nextMode }),
            });
          } catch (e) {}
        },
        async fetchOllamaModels() {
          this.ollamaLoading = true;
          try {
            const res = await fetch('/api/ollama-models');
            if (res.ok) {
              const data = await res.json();
              this.ollamaModels = data.models || [];
              if (!this.selectedModel && this.ollamaModels.length) this.selectedModel = this.ollamaModels[0].id;
            }
          } catch (e) {}
          this.ollamaLoading = false;
        },
        saveLocalConfig() {
          // Persist local selection immediately (so reload doesn't reset to first model)
          if (!this.selectedModel) return;
          fetch('/api/config', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: 'local', localModel: this.selectedModel }),
          }).then((r) => r.ok && r.json().then((c) => { this.config = c; }));
        },
        onRemoteProviderChange() {
          this.remoteModel = '';
          this.remoteCustomModel = '';
          this.saveRemoteConfig();
          this.checkRemoteCredentials();
        },
        saveRemoteConfig() {
          const model = this.effectiveRemoteModel;
          const remote = {
            provider: this.remoteProvider || undefined,
            model: model || undefined,
            baseUrl: this.remoteBaseUrl.trim() || undefined,
            apiKeyEnv: this.remoteProvider === 'other' ? (this.remoteCustomEnvKey.trim() || undefined) : undefined,
          };
          fetch('/api/config', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: 'remote', remote }),
          }).then((r) => r.ok && r.json().then((c) => { this.config = c; }));
        },
        async start() {
          if (!this.canStart()) return;
          try {
            await fetch('/api/config', {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                mode: this.mode,
                localModel: this.mode === 'local' ? this.selectedModel : undefined,
                ...(this.mode === 'remote' ? { remote: { provider: this.remoteProvider, model: this.effectiveRemoteModel, baseUrl: this.remoteBaseUrl.trim() || undefined, apiKeyEnv: this.remoteProvider === 'other' ? (this.remoteCustomEnvKey.trim() || undefined) : undefined } } : {}),
              }),
            });
            const model = this.mode === 'local' ? this.selectedModel : this.effectiveRemoteModel;
            const res = await fetch('/api/start', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                mode: this.mode,
                model,
                ...(this.mode === 'remote' && this.remoteApiKey.trim() ? { remoteApiKey: this.remoteApiKey.trim() } : {}),
              }),
            });
            const data = await res.json();
            if (data.error) alert(data.error);
            else this.refresh();
          } catch (e) {
            alert(e.message);
          }
        },
        async stop() {
          try {
            await fetch('/api/stop', { method: 'POST' });
            this.refresh();
          } catch (e) {
            alert(e.message);
          }
        },

        async refreshSessions() {
          this.loadingSessions = true;
          this.sessionsError = '';
          try {
            const r = await fetch('/api/sessions');
            const data = await r.json();
            if (!r.ok || !data.ok) throw new Error(data.error || 'Failed to load sessions');
            // Expected shape: { ok:true, result:{ sessions:[...] } }
            this.sessions = (data.result && data.result.sessions) ? data.result.sessions : (Array.isArray(data.result) ? data.result : []);
          } catch (e) {
            this.sessionsError = e.message;
          } finally {
            this.loadingSessions = false;
          }
        },

        async spawnSession() {
          const task = (this.spawnTask || '').trim();
          if (!task) return;
          this.spawning = true;
          this.sessionsError = '';
          try {
            const r = await fetch('/api/sessions/spawn', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                label: (this.spawnLabel || '').trim() || undefined,
                task,
                cleanup: 'keep',
              }),
            });
            const data = await r.json();
            if (!r.ok || !data.ok) throw new Error(data.error || 'Spawn failed');
            // Clear task box on success
            this.spawnTask = '';
            await this.refreshSessions();
          } catch (e) {
            this.sessionsError = e.message;
          } finally {
            this.spawning = false;
          }
        },

        async openSession(s) {
          this.detailSession = s || {};
          this.detailSessionHistory = null;
          this.sessionHistoryError = '';
          this.sessionModal.show();
          await this.reloadSessionHistory();
        },

        async deleteSession(s) {
          const key = s && s.key ? s.key : '';
          if (!key) return;
          if (!confirm('Close session? This removes it from the sessions list (transcript will be archived).')) return;
          this.sessionsError = '';
          try {
            const r = await fetch('/api/sessions/' + encodeURIComponent(key) + '/delete', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ deleteTranscript: true }),
            });
            const data = await r.json();
            if (!r.ok || !data.ok) throw new Error(data.error || 'Delete failed');
            // If we were viewing it, clear the modal state.
            if (this.detailSession && this.detailSession.key === key) {
              this.detailSession = {};
              this.detailSessionHistory = null;
            }
            await this.refreshSessions();
          } catch (e) {
            this.sessionsError = e.message;
          }
        },

        async reloadSessionHistory() {
          const key = this.detailSession && this.detailSession.key ? this.detailSession.key : '';
          if (!key) return;
          this.loadingSessionHistory = true;
          this.sessionHistoryError = '';
          try {
            const r = await fetch('/api/sessions/' + encodeURIComponent(key) + '/history?limit=50');
            const data = await r.json();
            if (!r.ok || !data.ok) throw new Error(data.error || 'Failed to load history');
            this.detailSessionHistory = data.result;
          } catch (e) {
            this.sessionHistoryError = e.message;
          } finally {
            this.loadingSessionHistory = false;
          }
        },

        openActivity(a) {
          this.detailActivity = a;
          this.activityModal.show();
        },
        async refreshDashboard() {
          try {
            const res = await fetch('/api/dashboard/summary');
            if (res.ok) {
              const data = await res.json();
              this.dashboardSummaryRaw = data?.data?.raw || '';
              this.dashboardSummaryParsed = data?.data?.parsed || null;
            }
          } catch (e) {}
        },
        async runCronJob(j) {
          if (!confirm('Run cron job now?\n\n' + (j.name || j.jobId))) return;
          try {
            const res = await fetch('/api/cron/' + encodeURIComponent(j.jobId) + '/run', { method: 'POST' });
            const data = await res.json();
            if (!res.ok || !data.ok) alert(data?.data?.stderr || data?.error?.message || 'Cron run failed');
            await this.refresh();
          } catch (e) {
            alert(e.message);
          }
        },
        async openCronRuns(j) {
          this.detailCron = j;
          this.cronRuns = [];
          try {
            const res = await fetch('/api/cron/' + encodeURIComponent(j.jobId) + '/runs?limit=20');
            if (res.ok) {
              const data = await res.json();
              this.cronRuns = data?.data?.runs || [];
            }
          } catch (e) {}
          this.cronRunsModal.show();
        },
        openCron(j) {
          this.detailCron = j;
          this.cronModal.show();
        },
      },
    });
  </script>
</body>
</html>
